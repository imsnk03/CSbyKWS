











    1. Introduction
    2. Reading and writing to a console
    3. Built-in data types
    4. String data type
    5. Operators

    6. Nullable Types
    7. Datatype conversions
    8. Arrays
    9. Comments
    10. If statement

    11. Switch statement
    12. Switch continued
    13. While loop
    14. Do while loop
    15. For & foreach loop

    16. Methods
    17. Method parameters
    18. Namespaces
    19. Class - Introduction
    20. Static & Instance members

    21. Inheritance
    22. Method hiding
    23. Polymorphism
    24. Method overriding Vs hiding
    25. Method overloading

    26. Why Properties
    27. Properties
    28. Structs
    29. Classes Vs Structs
    30. Interfaces

    31. Explicit interface implementation
    32. Abstract Classes
    33. Abstract Classes Vs Interfaces
    34. Diamond Problem
    35. Multiple inheritance

    36. Delegates
    37. Delegates Example - I
    38. Delegates Example - II
    39. Multicast Delegates
    40. Exception Handling

    41. Inner Exceptions
    42. Custom Exceptions
    43. Exception Handling Abuse
    44. Preventing Exception Handling Abuse
    45. Why Enums

    46. Enums Example
    47. Enums Concepts
    48. Types v/s Type Members
    49. Access Modifiers - Private, Public and Protected
    50. Access Modifiers - Internal and Protected Internal

++>By 15 June<++





    51. Access Modifiers for types
    52. Attributes
    53. Reflection
    54. Reflection Example
    55. Late binding using reflection

    56. Generics
    57. Generic Collections
    57. Reason to override ToString() method
    58. Reason to override Equals() method
    59. Difference between Convert.ToString() and ToString() method
    60. Difference between string and stringbuilder

    61. Partial classes in C#
    62. Creating partial classes in C#
    63. Partial methods in c# - Part 63
    64. How and where are indexers used in .net
    65. Indexers in c#

    66. Overloading indexers
    67. Optional parameters
    68. Making method parameters optional using method overloading
    69. Making method parameters optional by specifying parameter defaults
    70. Making method parameters optional by using OptionalAttribute

    71. Code snippets in visual studio
    72. What is dictionary in c#
    73. What is dictionary in c# continued
    74. List collection class in c#
    75. List collection class in c# continued

    76. Working with generic list class and ranges in c#
    77. Sort a list of simple types in c#
    78. Sort a list of complex types in c#
    79. Sort a list of complex types using Comparison delegate
    80. Some useful methods of List collection class

    81. When to use a dictionary over list in c#
    82. Generic queue collection class
    83. Generic stack collection class
    84. Real time example of queue collection class in c#
    85. Real time example of stack collection class in c#

    86. Multithreading in C#
    87. Advantages and disadvantages of multithreading
    88. ThreadStart delegate
    89. ParameterizedThreadStart delegate
    90. Passing data to the Thread function in a type safe manner

    91. Retrieving data from Thread function using callback method
    92. Significance of Thread.Join and Thread.IsAlive functions
    93. Protecting shared resources from concurrent access in multithreading
    94. Difference between Monitor and lock in C#
    95. Deadlock in a multithreaded program

    96. How to resolve a deadlock in a multithreaded program
    97. Performance of a multithreaded program
    98. Anonymous methods in c#
    99. Lambda expression in c#
    100. Func delegate in c#
    101. Async and await in c#
    102. How to wait for a thread to finish without blocking
